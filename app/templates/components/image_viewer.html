<!-- Global fullscreen image viewer -->
<div id="image-lightbox" class="fixed inset-0 z-[1000] hidden bg-black/90 select-none" aria-hidden="true" role="dialog" aria-label="Image viewer">
  <!-- Controls (top-left) -->
  <div class="absolute top-4 left-4 flex gap-2">
    <button type="button" aria-label="تكبير" title="تكبير" class="js-zoom-in px-3 py-2 rounded-md bg-white/10 text-white border border-white/20 hover:bg-white/20">
      <i class="fa-solid fa-magnifying-glass-plus"></i>
    </button>
    <button type="button" aria-label="تصغير" title="تصغير" class="js-zoom-out px-3 py-2 rounded-md bg-white/10 text-white border border-white/20 hover:bg-white/20">
      <i class="fa-solid fa-magnifying-glass-minus"></i>
    </button>
    <button type="button" aria-label="إعادة الضبط" title="إعادة الضبط" class="js-reset px-3 py-2 rounded-md bg-white/10 text-white border border-white/20 hover:bg-white/20">
      <i class="fa-solid fa-rotate-left"></i>
    </button>
  </div>
  <!-- Close (top-right) -->
  <button type="button" class="js-close absolute top-4 right-4 px-3 py-2 rounded-md bg-white/10 text-white border border-white/20 hover:bg-white/20" aria-label="إغلاق" title="إغلاق">
    <i class="fa-solid fa-xmark"></i>
  </button>

  <!-- Prev/Next -->
  <button type="button" class="js-prev absolute left-4 top-1/2 -translate-y-1/2 px-3 py-2 rounded-md bg-white/10 text-white border border-white/20 hover:bg-white/20" aria-label="السابق" title="السابق">
    <i class="fa-solid fa-chevron-left"></i>
  </button>
  <button type="button" class="js-next absolute right-4 top-1/2 -translate-y-1/2 px-3 py-2 rounded-md bg-white/10 text-white border border-white/20 hover:bg-white/20" aria-label="التالي" title="التالي">
    <i class="fa-solid fa-chevron-right"></i>
  </button>

  <!-- Stage -->
  <div class="js-stage w-full h-full overflow-hidden flex items-center justify-center touch-none">
    <img class="js-image max-w-none pointer-events-auto will-change-transform" alt="" draggable="false" />
  </div>

  <!-- Counter (bottom center) -->
  <div class="js-counter absolute bottom-4 left-1/2 -translate-x-1/2 text-white/80 text-sm"></div>
</div>

<script>
(function(){
  if (window.__imageLightboxInitialized) return; // avoid duplicate bindings
  window.__imageLightboxInitialized = true;

  const overlay = document.getElementById('image-lightbox');
  if (!overlay) return;
  const stage = overlay.querySelector('.js-stage');
  const img = overlay.querySelector('.js-image');
  const btnClose = overlay.querySelector('.js-close');
  const btnZoomIn = overlay.querySelector('.js-zoom-in');
  const btnZoomOut = overlay.querySelector('.js-zoom-out');
  const btnReset = overlay.querySelector('.js-reset');
  const btnPrev = overlay.querySelector('.js-prev');
  const btnNext = overlay.querySelector('.js-next');
  const counterEl = overlay.querySelector('.js-counter');

  let isOpen = false;
  let scale = 1;
  let translateX = 0;
  let translateY = 0;
  const MIN_SCALE = 1;
  const MAX_SCALE = 6;
  const ZOOM_STEP = 0.25;

  // Slideshow state
  let currentList = null; // [{ src, alt }]
  let currentIndex = 0;

  // Touch pinch state
  let isPinching = false;
  let pinchStartDistance = 0;
  let pinchStartScale = 1;

  function applyTransform(){
    img.style.transform = `translate(${translateX}px, ${translateY}px) scale(${scale})`;
  }

  function clampTranslation(){
    const rect = stage.getBoundingClientRect();
    const imgW = (img.naturalWidth || rect.width) * scale;
    const imgH = (img.naturalHeight || rect.height) * scale;
    const maxX = Math.max(0, (imgW - rect.width) / 2);
    const maxY = Math.max(0, (imgH - rect.height) / 2);
    translateX = Math.min(maxX, Math.max(-maxX, translateX));
    translateY = Math.min(maxY, Math.max(-maxY, translateY));
  }

  function updateCounter(){
    if (!counterEl) return;
    if (!currentList || currentList.length <= 1) { counterEl.textContent = ''; return; }
    counterEl.textContent = (currentIndex + 1) + ' / ' + currentList.length;
  }

  function showNavButtons(){
    const visible = currentList && currentList.length > 1;
    if (btnPrev) btnPrev.style.display = visible ? '' : 'none';
    if (btnNext) btnNext.style.display = visible ? '' : 'none';
  }

  function renderCurrent(){
    const item = currentList && currentList[currentIndex];
    const src = item ? item.src : '';
    const alt = item ? (item.alt || '') : '';
    if (!src) return;
    img.src = src;
    img.alt = alt;
    scale = 1; translateX = 0; translateY = 0; applyTransform();
    updateCounter();
  }

  function openViewer(src, alt){
    if (!src) return;
    openViewerFromList([{ src, alt: alt || '' }], 0);
  }

  function openViewerFromList(list, startIndex){
    if (!list || !list.length) return;
    currentList = list.slice();
    currentIndex = Math.min(Math.max(0, startIndex || 0), currentList.length - 1);
    overlay.classList.remove('hidden');
    overlay.setAttribute('aria-hidden', 'false');
    document.body.style.overflow = 'hidden';
    isOpen = true;
    showNavButtons();
    renderCurrent();
    img.focus && img.focus();
  }

  function closeViewer(){
    overlay.classList.add('hidden');
    overlay.setAttribute('aria-hidden', 'true');
    document.body.style.overflow = '';
    img.removeAttribute('src');
    isOpen = false;
    currentList = null;
    currentIndex = 0;
    updateCounter();
  }

  function zoomBy(delta){
    const prev = scale;
    scale = Math.min(MAX_SCALE, Math.max(MIN_SCALE, scale + delta));
    if (scale === MIN_SCALE) { translateX = 0; translateY = 0; }
    else if (scale !== prev) { clampTranslation(); }
    applyTransform();
  }

  // Expose helper
  window.openImageLightbox = openViewer; // single image
  window.openImageSlideshow = openViewerFromList; // list variant

  // Buttons
  btnClose.addEventListener('click', closeViewer);
  btnZoomIn.addEventListener('click', () => zoomBy(ZOOM_STEP));
  btnZoomOut.addEventListener('click', () => zoomBy(-ZOOM_STEP));
  btnReset.addEventListener('click', () => { scale = 1; translateX = 0; translateY = 0; applyTransform(); });
  if (btnPrev) btnPrev.addEventListener('click', () => navigate(-1));
  if (btnNext) btnNext.addEventListener('click', () => navigate(1));

  function navigate(delta){
    if (!isOpen || !currentList || currentList.length < 2) return;
    const len = currentList.length;
    currentIndex = (currentIndex + (delta % len) + len) % len;
    renderCurrent();
  }

  // Close on overlay click (except when clicking the image itself)
  overlay.addEventListener('click', (e) => {
    if (e.target === overlay) closeViewer();
  });

  // Wheel zoom
  stage.addEventListener('wheel', (e) => {
    if (!isOpen) return;
    e.preventDefault();
    const direction = e.deltaY > 0 ? -1 : 1;
    zoomBy(direction * ZOOM_STEP);
  }, { passive: false });

  // Drag to pan
  let dragging = false; let startX = 0; let startY = 0; let startTX = 0; let startTY = 0;
  function canPan(){ return scale > 1; }
  function onPointerDown(x, y){
    if (!isOpen || !canPan()) return;
    dragging = true; startX = x; startY = y; startTX = translateX; startTY = translateY;
    stage.style.cursor = 'grabbing';
  }
  function onPointerMove(x, y){
    if (!dragging) return;
    translateX = startTX + (x - startX);
    translateY = startTY + (y - startY);
    clampTranslation();
    applyTransform();
  }
  function onPointerUp(){ dragging = false; stage.style.cursor = ''; }

  // Mouse
  stage.addEventListener('mousedown', (e)=>{ if (e.button===0) onPointerDown(e.clientX, e.clientY); });
  window.addEventListener('mousemove', (e)=> onPointerMove(e.clientX, e.clientY));
  window.addEventListener('mouseup', onPointerUp);

  // Touch
  function distanceBetweenTouches(touches){
    const [a, b] = [touches[0], touches[1]];
    const dx = a.clientX - b.clientX;
    const dy = a.clientY - b.clientY;
    return Math.hypot(dx, dy);
  }

  stage.addEventListener('touchstart', (e)=>{
    if (!isOpen) return;
    if (e.touches.length === 1) {
      const t = e.touches[0];
      onPointerDown(t.clientX, t.clientY);
    } else if (e.touches.length === 2) {
      isPinching = true;
      pinchStartDistance = distanceBetweenTouches(e.touches);
      pinchStartScale = scale;
      e.preventDefault();
    }
  }, { passive: false });

  stage.addEventListener('touchmove', (e)=>{
    if (!isOpen) return;
    if (isPinching && e.touches.length === 2) {
      const currentDistance = distanceBetweenTouches(e.touches);
      const nextScale = pinchStartScale * (currentDistance / Math.max(1, pinchStartDistance));
      const clamped = Math.min(MAX_SCALE, Math.max(MIN_SCALE, nextScale));
      scale = clamped;
      clampTranslation();
      applyTransform();
      e.preventDefault();
    } else if (!isPinching && e.touches.length === 1) {
      const t = e.touches[0];
      onPointerMove(t.clientX, t.clientY);
    }
  }, { passive: false });

  stage.addEventListener('touchend', (e)=>{
    if (e.touches.length < 2) {
      isPinching = false;
    }
    if (e.touches.length === 0) onPointerUp();
  });

  // Double click/tap to toggle zoom
  let lastTap = 0;
  stage.addEventListener('click', ()=>{
    const now = Date.now();
    if (now - lastTap < 300) {
      if (scale === 1) zoomBy(1);
      else { scale = 1; translateX = 0; translateY = 0; applyTransform(); }
    }
    lastTap = now;
  });

  // Keyboard
  window.addEventListener('keydown', (e)=>{
    if (!isOpen) return;
    if (e.key === 'Escape') closeViewer();
    if (e.key === '+' || e.key === '=') { e.preventDefault(); zoomBy(ZOOM_STEP); }
    if (e.key === '-' || e.key === '_') { e.preventDefault(); zoomBy(-ZOOM_STEP); }
    if (e.key === '0') { e.preventDefault(); scale = 1; translateX = 0; translateY = 0; applyTransform(); }
    if (e.key === 'ArrowRight') { e.preventDefault(); navigate(1); }
    if (e.key === 'ArrowLeft') { e.preventDefault(); navigate(-1); }
  });

  // Delegated open (groups supported via [data-gallery])
  document.addEventListener('click', (e)=>{
    const target = e.target.closest('img.js-zoomable, img[data-zoomable]');
    if (!target) return;
    e.preventDefault();

    // Prefer grouping by nearest container with [data-gallery]
    const container = target.closest('[data-gallery]');
    let list = [];
    let startIndex = 0;
    if (container) {
      const imgs = Array.from(container.querySelectorAll('img.js-zoomable, img[data-zoomable]'));
      list = imgs.map(el => ({
        src: el.getAttribute('data-full') || el.currentSrc || el.src,
        alt: el.getAttribute('alt') || ''
      }));
      startIndex = Math.max(0, imgs.indexOf(target));
    } else {
      const groupName = target.getAttribute('data-gallery');
      if (groupName) {
        const selector = `img.js-zoomable[data-gallery="${groupName}"], img[data-zoomable][data-gallery="${groupName}"]`;
        const imgs = Array.from(document.querySelectorAll(selector));
        if (imgs.length > 0) {
          list = imgs.map(el => ({
            src: el.getAttribute('data-full') || el.currentSrc || el.src,
            alt: el.getAttribute('alt') || ''
          }));
          startIndex = Math.max(0, imgs.indexOf(target));
        }
      }
    }

    if (list.length > 1) {
      openViewerFromList(list, startIndex);
    } else {
      const src = target.getAttribute('data-full') || target.currentSrc || target.src;
      const alt = target.getAttribute('alt') || '';
      openViewer(src, alt);
    }
  });
})();
</script>
